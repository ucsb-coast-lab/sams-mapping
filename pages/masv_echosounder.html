<html>
<head>
  <meta charset="utf-8" />
  <title>Log File Data</title>
  <link rel="stylesheet" href="../assets/styles.css">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

  <!-- Load OpenLayers -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.5.0/css/ol.css" type="text/css">
  <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.5.0/build/ol.js"></script>

  <!-- Load CSV parsing library -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  <!-- Load Math library -->
  <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>

  <!-- Load a set of map helper functions-->
  <script type="text/javascript" src="map_fn.js"></script>

  <!-- Load rainbowvis.js file  -->
  <script src="rainbowvis.js"></script>

  <style>
    body { margin:0; padding: 0; }
    #map { position: absolute; top:100; bottom:0; right:0; left:0; }
  </style>
</head>
<body>
<a href="index.html"><img src="../assets/coast_logo.png" alt="coast_lab logo" style="width:300px;height:50 px;"></a>
<div>Please select a .geojson file for processing:</div>
<div>
  <span><input type="file" id="fileInput" name="geojson_upload" /></span>
  <span id="min">Min: </span>
  <span id="max">Max: </span>
  <span id="mean">Mean: </span>
</div>
<div>Please select a second .geojson file for processing:</div>
<div>
  <span><input type="file" id="fileInput2" name="geojson_upload" /></span>
  <span id="min2">Min: </span>
  <span id="max2">Max: </span>
  <span id="mean2">Mean: </span>
</div>
<div id="map" class="map" style="width: 1000px; height: 600px; margin-top: 50px;"></div>
<div id="popup" class="ol-popup">
  <a href="#" id="popup-closer" class="ol-popup-closer"></a>
  <div id="popup-content"></div>
</div>
<h2>
    MASV echosounder data:
</h2>

<script>
  document.getElementById('fileInput').addEventListener('change', addInitData);
  document.getElementById('fileInput2').addEventListener('change', addCompData);
  var map = createMap(2, [0,0]);
  function addInitData(evt) {
    var f = evt.target.files[0]; 
    if(f){
      var r = new FileReader();
      r.onload = function(e) { 
        var text = e.target.result;
        map.getLayers().forEach(layer => {
          if (layer !== basemap) {
            map.removeLayer(layer);
          }
        });
        var latTotal = 0;
        var lonTotal = 0;
        var depths = [];
        try{      
          json = JSON.parse(text);
          features = json.features;
          features.forEach(feature => {
            feature.geometry.coordinates = ol.proj.fromLonLat([feature.geometry.coordinates[1], feature.geometry.coordinates[0]]);
            latTotal += feature.geometry.coordinates[1];
            lonTotal += feature.geometry.coordinates[0];
            depths.push(feature.properties.depth);
          })
        }catch(e){
          //Handles old format where each line is a feature
          var allRows = text.split(/\r?\n|\r/);
          var features = [];
          allRows.map(row => {
            try{
              if(row !== ""){
                row = JSON.parse(row);
                row.geometry.coordinates = ol.proj.fromLonLat([row.geometry.coordinates[1], row.geometry.coordinates[0]]);
                latTotal += row.geometry.coordinates[1];
                lonTotal += row.geometry.coordinates[0];
                depths.push(row.properties.depth);
                features.push(row);
              }
            }catch (e){
              alert("Failed to load file, must be a .geojson");
            }
          })
        }

        document.getElementById('min').innerHTML= "Min: " + Math.min(...depths);
        document.getElementById('max').innerHTML= "Max: " + Math.max(...depths);
        document.getElementById('mean').innerHTML= "Mean: " + depths.reduce((a, b) => parseInt(a) + parseInt(b), 0) / depths.length;

        addMinMaxGradient('blue', 'orange', features, depths);

        const geojson = {
          'type': 'FeatureCollection',
          'features': features,
        };

        map.getView().setCenter([lonTotal/features.length, latTotal/features.length]);
        map.getView().setZoom(16);

        function styleFunction (feature) {
          let color = feature.get("color");
          let text = feature.get("label")
          if(text !== undefined){
            color = "yellow"
          }
          var point_style = {
            'Point': new ol.style.Style({
              image: new ol.style.Circle({
                radius: 2,
                fill: new ol.style.Fill({color: color}),
              }),
              text: new ol.style.Text({
                text: text,
                offsetY: -10,
                scale: 1,
                fill: new ol.style.Fill({
                    color: 'yellow',
                })
              })
            }),  
          };
          return point_style[feature.getGeometry().getType()];
        };
        var point_layer = createLayer(new ol.format.GeoJSON().readFeatures(geojson), styleFunction);
        map.addLayer(point_layer);
      }
      r.readAsText(f);
    }
    else { 
      alert("Failed to load file");
    }
  }

  function addCompData(evt) {
    var f = evt.target.files[0]; 
    if(f){
      var r = new FileReader();
      r.onload = function(e) { 
        var text = e.target.result;
        var latTotal = 0;
        var lonTotal = 0;
        var depths = [];
        try{      
          json = JSON.parse(text);
          features = json.features;
          features.forEach(feature => {
            feature.geometry.coordinates = ol.proj.fromLonLat([feature.geometry.coordinates[1], feature.geometry.coordinates[0]]);
            latTotal += feature.geometry.coordinates[1];
            lonTotal += feature.geometry.coordinates[0];
            depths.push(feature.properties.depth);
          })
        }catch(e){
          //Handles old format where each line is a feature
          var allRows = text.split(/\r?\n|\r/);
          var features = [];
          allRows.map(row => {
            try{
              if(row !== ""){
                row = JSON.parse(row);
                row.geometry.coordinates = ol.proj.fromLonLat([row.geometry.coordinates[1], row.geometry.coordinates[0]]);
                latTotal += row.geometry.coordinates[1];
                lonTotal += row.geometry.coordinates[0];
                depths.push(row.properties.depth);
                features.push(row);
              }
            }catch (e){
              alert("Failed to load file, must be a .geojson");
            }
          })
        }

        document.getElementById('min2').innerHTML= "Min: " + Math.min(...depths);
        document.getElementById('max2').innerHTML= "Max: " + Math.max(...depths);
        document.getElementById('mean2').innerHTML= "Mean: " + depths.reduce((a, b) => parseInt(a) + parseInt(b), 0) / depths.length;

        addMinMaxGradient('red', 'green', features, depths);

        const geojson = {
          'type': 'FeatureCollection',
          'features': features,
        };

        function styleFunction (feature) {
          let color = feature.get("color");
          let text = feature.get("label");
          if(text !== undefined){
            color = "purple"
          }
          var point_style = {
            'Point': new ol.style.Style({
              image: new ol.style.Circle({
                radius: 2,
                fill: new ol.style.Fill({color: color}),
              }),
              text: new ol.style.Text({
                text: text,
                offsetY: 10,
                scale: 1,
                fill: new ol.style.Fill({
                    color: 'purple',
                })
              })
            }),  
          };
          return point_style[feature.getGeometry().getType()];
        };
        var point_layer = createLayer(new ol.format.GeoJSON().readFeatures(geojson), styleFunction);
        map.addLayer(point_layer);
      }
      r.readAsText(f);
    }
    else { 
      alert("Failed to load file");
    }
  }
</script>

</body>
</html>
